use std::collections::HashMap;

use crate::{graphics::{ GraphicsContext}, platform::rustgl as gl};

#[derive(Clone, Copy)]
pub enum AccessModifier {
    ReadOnly = gl::READ_ONLY as isize,
    WriteOnly = gl::WRITE_ONLY as isize,
    ReadWrite = gl::READ_WRITE as isize,
}

#[derive(Clone, Copy)]
pub enum Barriers {
    ShaderImageAccess = gl::SHADER_IMAGE_ACCESS_BARRIER_BIT as isize,
}

#[derive(Clone, Copy)]
pub enum DrawMode {
    Points = gl::POINTS as isize,
    Lines = gl::LINES as isize,
    Triangles = gl::TRIANGLES as isize,
}

#[derive(Clone, Copy)]
pub enum DataType {
    Uint8 = gl::UNSIGNED_BYTE as isize,
    Uint16 = gl::UNSIGNED_SHORT as isize,
    Uint32 = gl::UNSIGNED_INT as isize,
    Int8 = gl::BYTE as isize,
    Int16 = gl::SHORT as isize,
    Int32 = gl::INT as isize,
    Float32 = gl::FLOAT as isize,
    NA,
}


fn error_source(source: u32) -> &'static str {
    match source {
        gl::DEBUG_SOURCE_API => "Calls to the OpenGL API",
        gl::DEBUG_SOURCE_WINDOW_SYSTEM => "Calls to a window-system API",
        gl::DEBUG_SOURCE_SHADER_COMPILER => "A compiler for a shading language",
        gl::DEBUG_SOURCE_THIRD_PARTY => "An application associated with OpenGL",
        gl::DEBUG_SOURCE_APPLICATION => "Generated by the user of this application",
        _ => ""
    }
}

fn error_severity(severity: u32) -> &'static str {
    match severity {
        gl::DEBUG_SEVERITY_HIGH => "High",
        gl::DEBUG_SEVERITY_MEDIUM => "Medium",
        gl::DEBUG_SEVERITY_LOW => "Low",
        gl::DEBUG_SEVERITY_NOTIFICATION => "Notification",
        _ => ""
    }
}

fn error_type(type_: u32) -> &'static str {
    match type_ {
        gl::DEBUG_TYPE_ERROR => "An error, typically from the API",
        gl::DEBUG_TYPE_DEPRECATED_BEHAVIOR => "Some behavior marked deprecated has been used",
        gl::DEBUG_TYPE_UNDEFINED_BEHAVIOR => "Something has invoked undefined behavior",
        gl::DEBUG_TYPE_PORTABILITY => "Some functionality the user relies upon is not portable",
        gl::DEBUG_TYPE_PERFORMANCE => "	Code has triggered possible performance issues",
        gl::DEBUG_TYPE_MARKER => "Command stream annotation",
        gl::DEBUG_TYPE_PUSH_GROUP => "Group pushing",
        gl::DEBUG_TYPE_POP_GROUP => "Group popping",
        _ => ""
    }
}


impl GraphicsContext {
    pub fn init(loader_function: &dyn Fn(&str) -> *const std::ffi::c_void) -> GraphicsContext {
        unsafe {
            gl::load_gl_functions(loader_function);
            // if let Err(res) = gl::load_gl_functions(loader_function) {
            //     for s in res {
            //         println!("{s}");
            //     }
            // }
        }
    
        let mut context = GraphicsContext {
            info: HashMap::new(),
        };
    
        #[cfg(debug_assertions)]
        context.debug_info();

        context
    }

    fn debug_info(&mut self) {
        unsafe {
            gl::debug_message_callback(|src, typ, id, sev, msg: &str| {
                let source = error_source(src);
                let severity = error_severity(sev);
                let type_ = error_type(typ);
                log::error!("{} :: {} :: {} :: {} :: {}", id, severity, type_, source, msg);
            });
        }
    
        self.info.insert("major_version", unsafe {
            gl::get_parameter_i32(gl::MAJOR_VERSION) as i64
        });
        self.info.insert("minor_version", unsafe {
            gl::get_parameter_i32(gl::MINOR_VERSION) as i64
        });
        self.info.insert("profile", unsafe {
            gl::get_parameter_i32(gl::CONTEXT_PROFILE_MASK) as i64
        });
        self.info.insert("uniform_buffer_offset_alignment", unsafe {
            gl::get_parameter_i32(gl::UNIFORM_BUFFER_OFFSET_ALIGNMENT) as i64
        });
        self.info.insert("max_uniform_buffer_size", unsafe {
            gl::get_parameter_i64(gl::MAX_UNIFORM_BLOCK_SIZE)
        });
        self.info.insert("shader_storage_offset_alignment", unsafe {
            gl::get_parameter_i32(gl::SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT) as i64
        });
        self.info.insert("max_shader_storage_size", unsafe {
            gl::get_parameter_i64(gl::MAX_SHADER_STORAGE_BLOCK_SIZE)
        });
    
        let profile = if *self.info.get("profile").unwrap() == 1 {
            "Core"
        } else {
            "Compatability"
        };
        let major_version = self.info.get("major_version").unwrap();
        let minor_version = self.info.get("minor_version").unwrap();
    
        log::info!(
            "API: OpenGL {}.{} in {} mode",
            major_version,
            minor_version,
            profile
        );
    }
}

pub fn set_viewport(x: u32, y: u32, width: u32, height: u32) {
    unsafe { gl::viewport(x as i32, y as i32, width as i32, height as i32) }
}

pub fn set_clear_color(r: f32, g: f32, b: f32, a: f32) {
    unsafe { gl::clear_color(r, g, b, a) }
}

pub fn memory_barrier(bitfield: u32) {
    unsafe { gl::memory_barrier(bitfield) }
}

pub fn submit_draw_call(
    mode: DrawMode,
    index_type: DataType,
    command_byte_offset: u32,
    command_count: u32,
) {
    unsafe {
        gl::multi_draw_elements_indirect_offset(
            mode as u32,
            index_type as u32,
            command_byte_offset as i32,
            command_count as i32,
            0,
        );
    }
}

// memory_manager.get_indirect_command_index() - command_count) * DRAW_COMMAND_SIZE
